---
title: "contrasts"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{contrasts}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
devtools::load_all(here::here("../vertical-lidar-paper"))
library(GET)
library(patchwork)
library(tibble)
library(ggplot2)
library(dplyr)
library(tidyr)
library(purrr)

ggplot2::theme_set(theme_pub())
alpha <- 0.05 / 3  # (Bonferroni correction)
nperm <- 100  # number of permutations
m <- 40-1  # number of discrete points per functions

# test variance equality
functional_anova <- function(g, nsim = nperm, contrasts = TRUE, curve_set = cset_trans, ...) {
  GET::graph.fanova(
    nsim = nsim,
    curve_set = curve_set,
    groups = g,
    variances = "unequal",
    test.equality = "var",
    contrasts = contrasts,
    alpha = alpha
    #lm.args = list(weights = weights$weight)
  )
}

# Transformation to equalize variances in groups
corrUnequalVar <- function(curve_set, groups, n.aver = 1L, mirror = FALSE) {
  if (!is.factor(groups)) {
    groups <- factor(groups)
  }
  x <- GET:::data_and_sim_curves(curve_set)
  # Group means, (bar{T}_j(r))
  m <- GET:::groupmeans(x, groups)
  # Sample variance over all functions, Var(T(r))
  varT <- GET:::vvar(x)
  # Variances in the groups, Var(T_j(r))
  v <- GET:::groupvar(x, groups)
  # Moving average
  if(n.aver>1){
    v <- t(apply(v, 1, GET:::maverage, n.aver=n.aver, mirror=mirror))
    varT <- GET:::maverage(varT, n.aver=n.aver, mirror=mirror)
  }
  # Take S_ij(r) = (T_ij(r) - \bar{T}_j(r)) / \sqrt( Var(T_j(r)) ) * Var(T(r)) + \bar{T}_j(r)
  for(i in 1:nrow(x)) {
    x[i,] <- (x[i,] - m[which(rownames(m) == groups[i]),]) / sqrt(v[which(rownames(v) == groups[i]),]) * sqrt(varT) + m[which(rownames(m) == groups[i]),]
  }
  curve_set$funcs <- t(x)
  curve_set
}
```

## Homogeneity

First, we need to test for variance homogeneity at every height.
```{r}
# wave can be create once with `source("data-raw/lidar_wave.R")`

# Transform to the GET format
mobs <-                         
  wave %>% 
  dplyr::select(starts_with("ss_")) %>% 
  as.matrix()

cset <- create_curve_set(list(r = seq_len(ncol(mobs)), obs = t(mobs)))

res_fanova_sp <- functional_anova(independent_factors$dominant_species, contrasts = FALSE, curve_set = cset)
my_plot_contrasts(res_fanova_sp, m)

# Successively equalize variance for each group
cset_trans <- corrUnequalVar(cset, groups=with(independent_factors, crown_closure))
res_fanova_sp <- functional_anova(independent_factors$dominant_species, contrasts = FALSE, curve_set = cset_trans)
plot(res_fanova_sp) + coord_flip()
cset_trans <- corrUnequalVar(cset_trans, groups=with(independent_factors, dominant_species))
res_fanova_sp <- functional_anova(independent_factors$dominant_species, contrasts = FALSE, curve_set = cset_trans)
plot(res_fanova_sp) + coord_flip()
cset_trans <- corrUnequalVar(cset_trans, groups=with(independent_factors, age_class))
res_fanova_sp <- functional_anova(independent_factors$dominant_species, contrasts = FALSE, curve_set = cset_trans)
plot(res_fanova_sp) + coord_flip()
```

It seems that the last transformation only moves heterogeneity to other areas of the curve. 

We can apply the transformation jointly (there aren't sufficient observations to apply to all variables combined), but it works for dominant species and crown closure, and then age in a second step.
```{r}
cset_trans <- corrUnequalVar(cset, groups=with(independent_factors, interaction(dominant_species, crown_closure)))
res_fanova_sp <- functional_anova(independent_factors$dominant_species, contrasts = FALSE, curve_set = cset_trans)
plot(res_fanova_sp) + coord_flip()
cset_trans <- corrUnequalVar(cset_trans, groups=with(independent_factors, age_class))
res_fanova_sp <- functional_anova(independent_factors$dominant_species, contrasts = FALSE, curve_set = cset_trans)
plot(res_fanova_sp) + coord_flip()
```
Applying the transformation by age group in the second step does not seem to improve the results.

## GLM

```{r}
independent_factors <- wave %>% 
  select(
    dominant_species, age_class, crown_closure
  ) %>% 
  mutate(
    dominant_species = factor(dominant_species),
    age_class = factor(age_class)
  ) %>% 
  as.data.frame()

trans_ss <- cset_trans[["funcs"]] %>% t() %>% 
  as_tibble() %>% 
  set_names(~paste0("trans_", .x))

wave_long <- wave %>% 
  # remove untransformed Y
  select(-matches("ss_")) %>%
  bind_cols(trans_ss) %>%
  pivot_longer(
    cols = matches("ss_"), 
    names_prefix = "(trans_)?ss_", 
    names_to = "height", 
    names_transform = list(height = as.integer),
    values_to = "ss"
  )
```

### Diagnose

It seems that issues with residuals could be due to the abundance of near-zero
predictors in some areas of the curve. 
```{r}
wave_long %>% 
  group_by(height, dominant_species) %>% 
  filter(ss < 1e-3) %>% 
  count() %>% 
  ggplot(aes(height / 40 * 100, n / nrow(wave) * 100, fill = dominant_species)) + 
  geom_col() + 
  ylab("Proportion of Y near zero (%)") +
  xlab("Relative height (%)") +
  coord_flip() 
```

# check residuals
```{r}
by_height <- wave_long %>% 
  group_by(height) %>% 
  nest()

box_cox <- function(x) {
  predict(caret::BoxCoxTrans(x + 1e-6), x)
}

sp_mod <- function(x) {
  lm(ss ~ dominant_species + age_class + crown_closure, data = x)
}

sp_mod_sqrt <- function(x) {
  lm(ss_sqrt ~ dominant_species + age_class + crown_closure, data = x)
}

minimum_variance_ratio <- function(x, group, at) {
  # "A rule of thumb is that linear models are fairly robust to heterogeneity
  # of variance so long as the maximum variance is no more than 4× greater
  # than the minimum variance"
  # ---https://stats.stackexchange.com/questions/91872/alternatives-to-one-way-anova-for-heteroskedastic-data/91881#91881
  
  vars <- x %>% 
    group_by({{group}}) %>% 
    summarise(var = var({{at}}, na.rm = TRUE), .groups = "drop_last")
  
  max(vars$var) / min(vars$var)
}

by_height <- by_height %>% 
  mutate(
    sp_model = map(data, sp_mod),
    sp_bptest = map(sp_model, lmtest::bptest),
    sp_bptest_statistic = map_dbl(sp_bptest, "statistic"),
    sp_bptest_p_value   = map_dbl(sp_bptest, "p.value"),  # p<0.05 with large BP >~ 10?
    # sp_ols_bptest = map(sp_model, olsrr::ols_test_breusch_pagan),
    # #sp_levene_test = map(sp_model, ~car::leveneTest(residuals(.x), groups = )),
    # sp_shapiro_test = map(sp_model, ~shapiro.test(sample(residuals(.x), size = 5e3))),
    # sp_shapiro_test_statistic = map_dbl(sp_shapiro_test, "statistic"),
    # sp_shapiro_test_p_value   = map_dbl(sp_shapiro_test, "p.value"),
    # sp_ols_test_f = map(sp_model, ols_test_f),

    sp_mvr = map_dbl(data, ~minimum_variance_ratio(.x, dominant_species, ss)),

    sp_kurtosis = map_dbl(sp_model, ~e1071::kurtosis(residuals(.x))),
    data = map2(data, sp_model, modelr::add_residuals, var = "resid"),
    data = map2(data, sp_model, modelr::add_predictions, var = "pred"),
    
    sp_mvr_res = map_dbl(data, ~minimum_variance_ratio(.x, dominant_species, pred))
  )
```

```{r}
# The maximum variance ration should 4
qplot(sp_mvr_res, height, data = by_height) + geom_path() + geom_vline(xintercept = 4) +
# kurtosis should be 0
#qplot(sp_kurtosis, height, data = by_height) + geom_path() + geom_vline(xintercept = 0) 

qplot(sp_bptest_statistic, height, data = by_height) + geom_path() +
qplot(sp_bptest_p_value, height, data = by_height) + geom_path()
```

```{r}
# View residuals by group
p <- by_height %>% 
  select(height, data) %>% 
  unnest(data) %>% 
  ggplot(aes(x = height / 40, y = resid, group = stand_id, color = dominant_species)) +
  coord_flip() +
  geom_line(show.legend = FALSE, alpha = 0.5) +
  scale_y_continuous("Scaled lidar return") +
  scale_x_continuous("Scaled height") +
  facet_grid(dominant_species + age_class ~crown_closure)

ggsave("res_fn.pdf", plot = p, width = 12, height = 44, units = "in")

by_height %>% 
  select(height, data) %>% 
  unnest(data) %>% 
  ggplot(aes(x = height / 40, y = resid, group = stand_id, color = dominant_species)) +
  coord_flip() +
  geom_line(show.legend = FALSE, alpha = 0.2)

# View residuals by model (height)
q <- by_height %>% 
  select(height, data) %>% 
  unnest(data) %>% 
  ggplot(aes(x = pred, y = resid %>% abs() %>% sqrt(), group = NA)) +
  geom_point(show.legend = FALSE, size = 0.5, alpha = 0.5) +
  facet_wrap(~I(round(height/40*100)), scales = "free") +
  geom_smooth(se = FALSE)

ggsave("res.pdf", plot = q, width = 12*2, height = 8*2, units = "in")
```

Since there are a lot of zeros in the upper portions, the log transform doesn't
seem to work, and the boxcox transformation either. It might be that the
variance is unequal between groups, which is something we observed. For that
reason, we could try to weight each model based on the inverse of group
variance. Combined to the sqare root transform, it seems to fix a few additional 
heights. 
```{r}
sp_mod_wls <- function(x) {
  lm(ss ~ dominant_species + crown_closure + age_class, data = x, weights = weight)
}

by_height <- by_height %>% 
  mutate(
    data = map(data, ~group_by(.x, dominant_species, crown_closure) %>% mutate(weight = 1/var(ss))),
    sp_model_wls = map(data, sp_mod_wls),
    data = map2(data, sp_model_wls, modelr::add_residuals, var = "resid_wls"),
    data = map2(data, sp_model_wls, modelr::add_predictions, var = "pred_wls"),
    sp_wls_bptest = map(sp_model_wls, lmtest::bptest),
    sp_wls_bptest_statistic = map_dbl(sp_wls_bptest, "statistic"),
    sp_wls_bptest_p_value   = map_dbl(sp_wls_bptest, "p.value"),  # p<0.05 with large BP >~ 10?

    sp_wls_kurtosis = map_dbl(sp_model, ~e1071::kurtosis(residuals(.x))),
    sp_wls_mvr_res = map_dbl(data, ~minimum_variance_ratio(.x, dominant_species, pred_wls))
  )
```


```{r}
# View residuals by model (height)
q <- by_height %>% 
  select(height, data) %>% 
  unnest(data) %>% 
  ggplot(aes(x = pred, y = resid_wls %>% abs() %>% sqrt(), group = NA, color = dominant_species)) +
  geom_point(show.legend = FALSE, size = 0.5, alpha = 0.5) +
  facet_wrap(~I(round(height/40*100)), scales = "free") +
  geom_smooth(se = FALSE)

ggsave("res_wls.pdf", plot = q, width = 12*2, height = 8*2, units = "in")

# With color by age
q <- by_height %>% 
  select(height, data) %>% 
  unnest(data) %>% 
  ggplot(aes(x = pred, y = resid_wls %>% abs() %>% sqrt(), group = NA, color = age_class)) +
  geom_point(show.legend = FALSE, size = 0.5, alpha = 0.5) +
  facet_wrap(~I(round(height/40*100)), scales = "free") +
  geom_smooth(se = FALSE)

ggsave("res_wls_age.pdf", plot = q, width = 12*2, height = 8*2, units = "in")
# Color by crown closure
q <- by_height %>% 
  select(height, data) %>% 
  unnest(data) %>% 
  ggplot(aes(x = pred, y = resid_wls %>% abs() %>% sqrt(), group = NA, color = crown_closure)) +
  geom_point(show.legend = FALSE, size = 0.5, alpha = 0.5) +
  facet_wrap(~I(round(height/40*100)), scales = "free") +
  geom_smooth(se = FALSE)

ggsave("res_wls_cc.pdf", plot = q, width = 12*2, height = 8*2, units = "in")
```

```{r}
# The maximum variance ration should 4
ggplot(data = by_height) + 
  geom_path(aes(sp_wls_mvr_res, height/40), color = "blue") + 
  geom_path(aes(sp_mvr_res, height/40)) + 
  geom_path(aes(sp_mvr, height/40), color = "red") + 
  geom_vline(xintercept = 4) +
  scale_y_continuous("Scaled height") +
# kurtosis should 0
#qplot(sp_kurtosis, height, data = by_height) + geom_path() + geom_vline(xintercept = 0) 
ggplot(data = by_height) + 
  geom_path(aes(sp_wls_bptest_statistic, height/40), color = "blue") +
  geom_path(aes(sp_bptest_statistic, height/40)) +
  scale_y_continuous("") +
qplot(sp_wls_bptest_p_value, height/40, data = by_height) + geom_path() +
  scale_y_continuous("") 
```

The envelopes are created from `r nperm` permutations.

To complete the correction for heteroscedasticity, we're going to use weight observations based on 

```{r}
weights <- by_height %>% 
  unnest(data) %>% 
  group_by(stand_id) %>% 
  summarise(weight = median(weight), .groups = "drop") 

weights %>% 
  ggplot(aes(weight)) +
  geom_histogram()
```


```{r}

functional_lm <- function(null_model, nsim = nperm, contrasts = TRUE) {
  graph.flm(
    nsim = nsim,
    formula.full = Y ~ dominant_species + age_class + crown_closure,
    formula.reduced = null_model,
    curve_sets = cset_trans,
    factors = independent_factors,
    contrasts = contrasts,
    GET.args = list(alpha = alpha)
  )
}
res_flm_sp <- functional_lm(Y ~ age_class + crown_closure)
res_flm_cc <- functional_lm(Y ~ dominant_species + age_class, contrasts = FALSE)
res_flm_age <- functional_lm(Y ~ dominant_species + crown_closure, contrasts = FALSE)

res_fanova_sp <- functional_anova(independent_factors$dominant_species, contrasts = FALSE, curve_set = cset)
res_fanova_sp_trans <- functional_anova(independent_factors$dominant_species, contrasts = FALSE, curve_set = cset_trans)
res_fanova_cc <- functional_anova(factor(independent_factors$crown_closure), contrasts = FALSE, curve_set = cset)
res_fanova_cc_trans <- functional_anova(factor(independent_factors$crown_closure), contrasts = FALSE, curve_set = cset_trans)
res_fanova_age <- functional_anova(independent_factors$age_class, contrasts = FALSE)
```

Check variance homogeneity
```{r}
plot(res_fanova_sp) + coord_flip() + plot(res_fanova_sp_trans) + coord_flip()
plot(res_fanova_cc) + coord_flip() + plot(res_fanova_cc_trans) + coord_flip()
```


### Contrasts
```{r}
p <- my_plot_contrasts(res_flm_sp, 39, full = TRUE)
pa <- my_plot_contrasts(res_fanova_sp, 39, full = TRUE)
# compare both results (fanova and flm)
p + pa

u <- my_plot_continuous(res_flm_cc, 39, main = "my main")  + scale_y_continuous("Scaled density difference (×10⁻⁴)", labels = function(x) paste0(x * 1000))
v <- my_plot_continuous(res_flm_age, 39) + scale_y_continuous("Scaled density difference (×10⁻³)", labels = function(x) paste0(x * 100))

(p + ggtitle("Species")) +
  ((u + ggtitle("Crown closure")) /
  (v + ggtitle("Age")))

# Save figures independently
# device <- "png" # pdf
# ggsave("figure/fig3-sp-contrasts.png", p, device = device, dpi = "retina", width = 234, height = 234, units = "mm")
# ggsave("figure/fig5-cc-contrasts.png", u, device = device, dpi = "retina", width = 234, height = 234, units = "mm")
# ggsave("figure/fig7-age-contrasts.png", v + scale_y_continuous("breaks = c(-0.2, 0, 0.2)"), device = device, dpi = "retina", width = 234, height = 234, units = "mm")
```

### Summary figure
```{r}
# Species variations ==========================================================
direct_labels <- tribble(
  ~label, ~r, ~curves,
  "Aspen", 0.75, 0.12,
  "Balsam fir", 0.56, 0.09,
  "Paper birch", 0.4, 0.11,
  "White spruce", 0.25, 0.14,
  "Black spruce", 0.05, 0.19
) %>% 
  mutate(a = tolower(label))

sp_v <- 
  res_flm_sp %>% 
  my_plot_data_combined_global_envelope(scale_r = 39) %>% 
  .$ribbon %>% 
  filter(
    type == "Data function",
  ) %>% 
  fill_contrast_matrix() %>% 
  group_by(a, r) %>% 
  summarise(
    curves = sum(abs(curves))
  ) %>% 
  ggplot(aes(x = r, y = curves)) + 
  geom_line(aes(group = a, color = a), show.legend = FALSE) +
  geom_line(data = . %>% group_by(r) %>% summarise(curves = sum(abs(curves)))) +
  geom_text(data = direct_labels, aes(label = label, color = a), show.legend = FALSE, hjust = "left") +
  xlab("Scaled Stand Height") +
  ylab("Sum of absolute scaled density difference") +
  scale_color_brewer("Species", type = "qual", palette = "Dark2") + 
  coord_flip()

# Crown closure variations ====================================================
cc_v <- res_flm_cc %>% 
  my_plot_data_combined_global_envelope(scale_r = 39, main = "main") %>% 
  .$ribbon %>% 
  filter(
    type == "Data function",
  ) %>% 
  fill_contrast_matrix() %>% 
  group_by(a, r) %>% 
  summarise(
    curves = sum(curves)
  ) %>% 
  ggplot(aes(x = r, y = curves)) + 
  geom_line(aes(group = interaction(a), color = a), show.legend = FALSE) +
  geom_line(data = . %>% group_by(r) %>% summarise(curves = sum(abs(curves)))) +
  xlab("Scaled Stand Height") +
  ylab("Sum of scaled density difference") +
  directlabels::geom_dl(aes(label = a, color = a), method = "last.bumpup") +
  scale_color_manual(values = pal_cc) +
  coord_flip()

# Age variations ===============================================================
age_v <- res_flm_age %>% 
  my_plot_data_combined_global_envelope(scale_r = 39) %>% 
  .$ribbon %>% 
  filter(
    type == "Data function",
  ) %>% 
  fill_contrast_matrix() %>% 
  group_by(a, r) %>% 
  summarise(
    curves = sum(curves)
  ) %>% 
  ggplot(aes(x = r, y = curves)) + 
  geom_line(aes(group = interaction(a), color = a), show.legend = FALSE) +
  geom_line(data = . %>% group_by(r) %>% summarise(curves = sum(abs(curves)))) +
  xlab("Scaled Stand Height") +
  ylab("Sum of scaled density difference") +
  scale_color_manual(values = pal_age) +
  directlabels::geom_dl(aes(label = a, color = a), method = "last.bumpup") +
  coord_flip()

sp_v + cc_v + age_v

res_flm_age %>% 
  my_plot_data_combined_global_envelope(scale_r = 39) %>% 
  .$ribbon %>% 
  filter(
    type == "Data function",
  ) %>% 
  fill_contrast_matrix() %>% 
  mutate(
    a = sort_num_factor(a),
    b = sort_num_factor(b)
  ) %>% 
  ggplot(aes(x = r, y = curves, group = interaction(type, a, b))) + 
  geom_ribbon(aes(x = r, ymin = lower, ymax = upper), fill = "black", alpha = 0.01) +
  geom_segment(aes(xend = x_end, yend = y_end, color = ifelse(!inside & !inside_lead, "outside", NA)), show.legend = FALSE) +
  xlab("Scaled Stand Height") +
  ylab("Scaled density difference") +
  facet_grid(~a)+
  coord_flip()
```

